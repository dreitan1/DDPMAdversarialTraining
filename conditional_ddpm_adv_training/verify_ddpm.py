# verify_ddpm.py

import os
import argparse
import torch
import torch.nn as nn
import torchvision
import torchvision.transforms as transforms
import matplotlib.pyplot as plt

from models.conditional_unet import ConditionalUnet
from models.conditional_diffusion import ConditionalGaussianDiffusion
from models.resnet_embedder import ResNetEmbedder
from models.resnet20 import ResNet20

# ========== Device Setup ==========
device = torch.device('cuda' if torch.cuda.is_available() else ('mps' if torch.backends.mps.is_available() else 'cpu'))
print(f"Using device: {device}")

# ========== Load CIFAR-10 Test Set ==========
def get_testloader(batch_size=1):
    transform = transforms.Compose([
        transforms.ToTensor(),
        transforms.Normalize((0.5,), (0.5,))
    ])
    testset = torchvision.datasets.CIFAR10(root='./data', train=False, download=True, transform=transform)
    testloader = torch.utils.data.DataLoader(testset, batch_size=batch_size, shuffle=True, num_workers=0)
    return testloader

# ========== Show and Save Images ==========
def show_and_save_images(original, generated, save_path):
    fig, axs = plt.subplots(1, 2, figsize=(8, 4))
    
    original = (original.permute(1, 2, 0) * 0.5 + 0.5).clamp(0, 1).cpu().numpy()
    generated = (generated.permute(1, 2, 0) * 0.5 + 0.5).clamp(0, 1).cpu().numpy()

    axs[0].imshow(original)
    axs[0].set_title("Original Clean Image")
    axs[0].axis('off')

    axs[1].imshow(generated)
    axs[1].set_title("Generated by DDPM")
    axs[1].axis('off')

    plt.tight_layout()
    os.makedirs(os.path.dirname(save_path), exist_ok=True)
    plt.savefig(save_path)
    plt.show()
    plt.close()

# ========== Main Execution ==========
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--resnet-path', type=str, required=True, help='Path to pretrained ResNet checkpoint')
    parser.add_argument('--diffusion-path', type=str, required=True, help='Path to trained DDPM checkpoint')
    parser.add_argument('--output-dir', type=str, default='outputs/', help='Directory to save generated images')
    parser.add_argument('--batch-size', type=int, default=1, help='Batch size for loading CIFAR-10')
    args = parser.parse_args()

    # Load data
    testloader = get_testloader(batch_size=args.batch_size)

    # Load ResNet
    resnet = ResNet20().to(device)
    resnet.load_state_dict(torch.load(args.resnet_path, map_location=device))
    resnet.eval()

    # Load Conditional DDPM
    unet = ConditionalUnet(image_channels=3, base_dim=64, embed_dim=256).to(device)
    diffusion = ConditionalGaussianDiffusion(model=unet, image_size=32, timesteps=1000).to(device)
    diffusion.load_state_dict(torch.load(args.diffusion_path, map_location=device))
    diffusion.eval()

    # Embedder
    embedder = ResNetEmbedder(resnet).to(device)

    # Sample one clean image
    x_clean, _ = next(iter(testloader))
    x_clean = x_clean.to(device)

    # Embed ResNet parameters
    embed = embedder()
    embed = embed.repeat(x_clean.size(0), 1)

    # Sample random timestep
    T = diffusion.num_timesteps
    t_sample = torch.randint(0, T, (x_clean.size(0),), device=device).long()

    # Noise the clean image and generate
    with torch.no_grad():
        noise = torch.randn_like(x_clean)
        x_noisy = diffusion.q_sample(x_start=x_clean, t=t_sample, noise=noise)

        # FIXED CALL: pass (x_noisy, x_clean, t, embed)
        x_gen = diffusion.model(x_noisy, x_clean, t_sample, embed)

    # Save and Show
    os.makedirs(args.output_dir, exist_ok=True)
    save_path = os.path.join(args.output_dir, 'ddpm_sample.png')
    show_and_save_images(x_clean[0], x_gen[0], save_path)

    print(f"âœ… Image saved to {save_path}")

# Run with multiprocessing protection
if __name__ == "__main__":
    main()